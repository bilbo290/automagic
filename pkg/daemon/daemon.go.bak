package daemon

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"syscall"
	"time"

	"peter/pkg/claude"
	"peter/pkg/config"
	"peter/pkg/gitlab"
	"peter/pkg/session"
)

type Daemon struct {
	gitlabClient    *gitlab.Client
	config          *config.Config
	selectedProject string
	processManager  *claude.ProcessManager
	sessionStore    *session.SessionStore
	resumeProcesses map[int]*exec.Cmd // Track resume processes by issue ID
	dryRun          bool
	semiDryRun      bool
}

func New(gitlabClient *gitlab.Client, config *config.Config) *Daemon {
	sessionStore := session.NewSessionStore("")
	sessionStore.Load() // Load existing sessions, ignore errors
	
	return &Daemon{
		gitlabClient:    gitlabClient,
		config:          config,
		processManager:  claude.NewProcessManager(),
		sessionStore:    sessionStore,
		resumeProcesses: make(map[int]*exec.Cmd),
		dryRun:          false,
	}
}

func NewWithDryRun(gitlabClient *gitlab.Client, config *config.Config, dryRun bool) *Daemon {
	sessionStore := session.NewSessionStore("")
	sessionStore.Load() // Load existing sessions, ignore errors
	
	return &Daemon{
		gitlabClient:    gitlabClient,
		config:          config,
		processManager:  claude.NewProcessManager(),
		sessionStore:    sessionStore,
		resumeProcesses: make(map[int]*exec.Cmd),
		dryRun:          dryRun,
	}
}

func NewWithSemiDryRun(gitlabClient *gitlab.Client, config *config.Config) *Daemon {
	sessionStore := session.NewSessionStore("")
	sessionStore.Load() // Load existing sessions, ignore errors
	
	return &Daemon{
		gitlabClient:    gitlabClient,
		config:          config,
		processManager:  claude.NewProcessManager(),
		sessionStore:    sessionStore,
		resumeProcesses: make(map[int]*exec.Cmd),
		dryRun:          false, // For semi-dry-run, we clone repos but don't execute
		semiDryRun:      true,
	}
}

func (d *Daemon) selectProject(projects []gitlab.Project) (*gitlab.Project, error) {
	if len(projects) == 0 {
		return nil, fmt.Errorf("no projects available")
	}

	if len(projects) == 1 {
		fmt.Printf("Only one project available: %s\n", projects[0].PathWithNamespace)
		return &projects[0], nil
	}

	fmt.Printf("\nSelect a project:\n")
	for i, project := range projects {
		fmt.Printf("%d. %s\n", i+1, project.PathWithNamespace)
		if project.Description != "" {
			fmt.Printf("   Description: %s\n", project.Description)
		}
		fmt.Printf("   URL: %s\n", project.WebURL)
		fmt.Printf("   Visibility: %s\n\n", project.Visibility)
	}

	fmt.Printf("Enter project number (1-%d): ", len(projects))

	var choice int
	for {
		_, err := fmt.Scanf("%d", &choice)
		if err != nil {
			fmt.Printf("Invalid input. Please enter a number: ")
			continue
		}

		if choice < 1 || choice > len(projects) {
			fmt.Printf("Invalid choice. Please enter a number between 1 and %d: ", len(projects))
			continue
		}

		break
	}

	selected := &projects[choice-1]
	fmt.Printf("\nSelected project: %s\n", selected.PathWithNamespace)
	return selected, nil
}

func (d *Daemon) processIssueWithLabelUpdate(issue *gitlab.Issue) error {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	
	if d.dryRun {
		fmt.Printf("[%s] [DRY RUN] Would process issue #%d: %s\n", timestamp, issue.IID, issue.Title)
	} else if d.semiDryRun {
		fmt.Printf("[%s] [SEMI-DRY RUN] Processing issue #%d: %s\n", timestamp, issue.IID, issue.Title)
	} else {
		fmt.Printf("[%s] Processing issue #%d: %s\n", timestamp, issue.IID, issue.Title)
	}

	// Update labels to mark as being processed
	newLabels := make([]string, 0)
	for _, label := range issue.Labels {
		if label != d.config.Daemon.ClaudeLabel {
			newLabels = append(newLabels, label)
		}
	}
	newLabels = append(newLabels, d.config.Daemon.ProcessLabel)

	if d.dryRun {
		fmt.Printf("[%s] [DRY RUN] Would update labels: remove '%s', add '%s'\n", timestamp, d.config.Daemon.ClaudeLabel, d.config.Daemon.ProcessLabel)
	} else if d.semiDryRun {
		fmt.Printf("[%s] [SEMI-DRY RUN] Would update labels: remove '%s', add '%s'\n", timestamp, d.config.Daemon.ClaudeLabel, d.config.Daemon.ProcessLabel)
	} else {
		if err := d.gitlabClient.UpdateIssueLabels(d.selectedProject, issue.IID, newLabels); err != nil {
			return fmt.Errorf("failed to update issue labels: %v", err)
		}
	}

	// Process the issue asynchronously with completion callback
	if err := d.processIssueAsync(issue.IID); err != nil {
		fmt.Printf("[%s] Error starting process for issue #%d: %v\n", time.Now().Format("2006-01-02 15:04:05"), issue.IID, err)
		return err
	}

	fmt.Printf("[%s] Started processing issue #%d\n", time.Now().Format("2006-01-02 15:04:05"), issue.IID)
	return nil
}

func (d *Daemon) processIssue(issueNumber int) error {
	processManager := claude.NewProcessManager()

	fmt.Printf("Processing issue #%d...\n", issueNumber)

	processID := fmt.Sprintf("issue-%d-%d", issueNumber, time.Now().Unix())

	process, err := claude.CreateProcess(
		issueNumber,
		processID,
		d.config.Claude.Command,
		d.config.Claude.Flags,
		d.selectedProject,
		d.config.GitLab.Username,
	)
	if err != nil {
		return fmt.Errorf("error creating claude process: %v", err)
	}

	processManager.AddProcess(process)

	if err := claude.RunProcess(process); err != nil {
		return fmt.Errorf("error executing claude command: %v", err)
	}

	return nil
}

func (d *Daemon) processIssueAsync(issueNumber int) error {
	if d.dryRun {
		fmt.Printf("[DRY RUN] Would start async process for issue #%d...\n", issueNumber)
	} else if d.semiDryRun {
		fmt.Printf("[SEMI-DRY RUN] Starting repository check for issue #%d...\n", issueNumber)
	} else {
		fmt.Printf("Starting async process for issue #%d...\n", issueNumber)
	}

	processID := fmt.Sprintf("issue-%d-%d", issueNumber, time.Now().Unix())

	// Define completion labels - remove process label and add review label
	completionLabels := []string{d.config.Daemon.ReviewLabel}

	// Create completion callback (runs asynchronously to avoid blocking)
	onCompletion := func(process *claude.Process, success bool) error {
		// Run completion tasks asynchronously to avoid blocking the main process
		go func() {
		timestamp := time.Now().Format("2006-01-02 15:04:05")
		
		if success {
			fmt.Printf("[%s] Successfully completed issue #%d\n", timestamp, process.IssueNum)
			
			// Update labels to mark as waiting for human review
			newLabels := make([]string, 0)
			
			// Get current issue to get current labels
			issue, err := d.gitlabClient.GetIssue(d.selectedProject, process.IssueNum)
			if err != nil {
				fmt.Printf("[%s] Warning: failed to get issue #%d for label update: %v\n", timestamp, process.IssueNum, err)
				return
			}
			
			// Remove process label and add review label
			for _, label := range issue.Labels {
				if label != d.config.Daemon.ProcessLabel {
					newLabels = append(newLabels, label)
				}
			}
			newLabels = append(newLabels, d.config.Daemon.ReviewLabel)
			
			// Update labels
			if err := d.gitlabClient.UpdateIssueLabels(d.selectedProject, process.IssueNum, newLabels); err != nil {
				fmt.Printf("[%s] Warning: failed to update completion labels for issue #%d: %v\n", timestamp, process.IssueNum, err)
			} else {
				fmt.Printf("[%s] Updated labels for issue #%d to '%s'\n", timestamp, process.IssueNum, d.config.Daemon.ReviewLabel)
			}
			
			// Store session information for comment monitoring
			if err := d.sessionStore.AddCompletedSession(
				process.IssueNum,
				process.ID,
				d.selectedProject,
				time.Now(),
			); err != nil {
				fmt.Printf("[%s] Warning: failed to store session info for issue #%d: %v\n", timestamp, process.IssueNum, err)
			} else {
				fmt.Printf("[%s] Stored session %s for issue #%d (monitoring for new comments)\n", timestamp, process.ID, process.IssueNum)
			}
		} else {
			fmt.Printf("[%s] Failed to complete issue #%d\n", timestamp, process.IssueNum)
			
			// Get current issue to get current labels
			issue, err := d.gitlabClient.GetIssue(d.selectedProject, process.IssueNum)
			if err != nil {
				fmt.Printf("[%s] Warning: failed to get issue #%d for label update: %v\n", timestamp, process.IssueNum, err)
				return
			}
			
			// Remove process label and add error label
			newLabels := make([]string, 0)
			for _, label := range issue.Labels {
				if label != d.config.Daemon.ProcessLabel {
					newLabels = append(newLabels, label)
				}
			}
			newLabels = append(newLabels, "error")
			
			// Update labels
			if err := d.gitlabClient.UpdateIssueLabels(d.selectedProject, process.IssueNum, newLabels); err != nil {
				fmt.Printf("[%s] Warning: failed to update error labels for issue #%d: %v\n", timestamp, process.IssueNum, err)
			} else {
				fmt.Printf("[%s] Updated labels for issue #%d to 'error'\n", timestamp, process.IssueNum)
			}
		}
		}() // End of async goroutine
		
		return nil // Return immediately from callback
	}

	process, err := claude.CreateProcessWithCallbackAndGitlabDryRun(
		issueNumber,
		processID,
		d.config.Claude.Command,
		d.config.Claude.Flags,
		d.selectedProject,
		d.config.GitLab.Username,
		d.config.GitLab.URL,
		d.dryRun,
		completionLabels,
		onCompletion,
	)
	if err != nil {
		return fmt.Errorf("error creating claude process: %v", err)
	}

	if d.dryRun || d.semiDryRun {
		if d.dryRun {
			fmt.Println("\n=== DRY RUN MODE (Daemon) ===")
		} else {
			fmt.Println("\n=== SEMI-DRY RUN MODE (Daemon) ===")
			fmt.Println("Repository has been cloned/verified.")
		}
		fmt.Printf("Issue #%d\n", issueNumber)
		fmt.Printf("Process ID: %s\n", processID)
		fmt.Printf("Working Directory: %s\n", process.Cmd.Dir)
		fmt.Printf("Command: %s\n", process.Cmd.Path)
		fmt.Printf("Arguments: %v\n", process.Cmd.Args)
		fmt.Println("\n=== PROMPT ===")
		// Extract the prompt from the command args
		for i, arg := range process.Cmd.Args {
			if arg == "-p" && i+1 < len(process.Cmd.Args) {
				fmt.Println(process.Cmd.Args[i+1])
				break
			}
		}
		
		if d.semiDryRun {
			fmt.Println("=== END SEMI-DRY RUN ===")
			
			// Additional repository checks in semi-dry-run mode
			fmt.Println("\n=== REPOSITORY STATUS ===")
			// Run git status in the repository directory
			statusCmd := exec.Command("git", "status", "--short")
			statusCmd.Dir = process.Cmd.Dir
			if output, err := statusCmd.Output(); err == nil {
				if len(output) == 0 {
					fmt.Println("Git status: Clean working directory")
				} else {
					fmt.Printf("Git status:\n%s", output)
				}
			}
			
			// Show current branch
			branchCmd := exec.Command("git", "branch", "--show-current")
			branchCmd.Dir = process.Cmd.Dir
			if output, err := branchCmd.Output(); err == nil {
				fmt.Printf("Current branch: %s", output)
			}
			
			fmt.Printf("\n[SEMI-DRY RUN] Would update labels: remove '%s', add '%s' on completion\n", d.config.Daemon.ProcessLabel, d.config.Daemon.ReviewLabel)
			
			// In semi-dry-run mode, show what cleanup would do
			fmt.Printf("\n=== REPOSITORY CLEANUP ===\n")
			fmt.Printf("After Claude finishes, the following cleanup would occur:\n")
			fmt.Printf("- Reset any uncommitted changes (git reset --hard HEAD)\n")
			fmt.Printf("- Remove untracked files (git clean -fd)\n")
			fmt.Printf("- Switch back to main branch\n")
			fmt.Printf("- Delete any issue-* branches\n")
			fmt.Printf("- Pull latest changes\n")
			fmt.Printf("Repository will be ready for the next parallel session\n")
		} else {
			fmt.Println("=== END DRY RUN ===\n")
			fmt.Printf("[DRY RUN] Would update labels: remove '%s', add '%s' on completion\n", d.config.Daemon.ProcessLabel, d.config.Daemon.ReviewLabel)
		}
	} else {
		d.processManager.AddProcess(process)

		// Run the process asynchronously
		claude.RunProcessAsync(process, d.processManager)
	}

	return nil
}


func (d *Daemon) resumeSessionWithComments(session *session.CompletedSession, newComments []gitlab.Note) error {
	timestamp := time.Now().Format("2006-01-02 15:04:05")
	
	// Build comment context
	commentContext := fmt.Sprintf("# New Comments on Issue #%d\n\n", session.IssueIID)
	commentContext += "The following comments were added after you completed this issue:\n\n"
	
	for i, comment := range newComments {
		commentContext += fmt.Sprintf("## Comment %d by @%s\n", i+1, comment.Author.Username)
		commentContext += fmt.Sprintf("**Posted:** %s\n\n", comment.CreatedAt)
		commentContext += fmt.Sprintf("%s\n\n", comment.Body)
		commentContext += "---\n\n"
	}
	
	commentContext += "Please review these comments and take any necessary follow-up actions. "
	commentContext += "You can update your previous work, answer questions, or make additional changes as needed."
	
	if d.dryRun {
		fmt.Printf("[%s] [DRY RUN] Would resume session %s with comment context:\n%s\n", timestamp, session.SessionID, commentContext)
		return nil
	} else if d.semiDryRun {
		fmt.Printf("[%s] [SEMI-DRY RUN] Would resume session %s with comment context:\n%s\n", timestamp, session.SessionID, commentContext)
		return nil
	}
	
	// Create resume command - use claude -r <session-id> with the comment context
	claudeCmd := fmt.Sprintf("%s %s -r %s -p %q", 
		d.config.Claude.Command, 
		d.config.Claude.Flags, 
		session.SessionID, 
		commentContext)
	
	fmt.Printf("[%s] Resuming Claude session %s for issue #%d with new comments\n", timestamp, session.SessionID, session.IssueIID)
	
	// Use the existing working directory detection logic
	workingDir, _, err := claude.DetectProjectDirectory(session.ProjectPath)
	if err != nil {
		return fmt.Errorf("failed to detect working directory: %v", err)
	}
	
	// Create a simple command execution (not using the full Process struct for resume)
	cmd := exec.Command("bash", "-c", claudeCmd)
	cmd.Dir = workingDir
	cmd.Env = os.Environ()
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	
	// Start the resume command asynchronously
	if err := cmd.Start(); err != nil {
		return fmt.Errorf("failed to start resume session: %v", err)
	}
	
	// Track this process for graceful shutdown
	d.resumeProcesses[session.IssueIID] = cmd
	
	fmt.Printf("[%s] Started resume session for issue #%d (PID: %d)\n", timestamp, session.IssueIID, cmd.Process.Pid)
	
	// Don't wait for completion - let it run in background
	// The process will complete on its own
	go func() {
		err := cmd.Wait()
		
		// Remove from tracking when completed
		delete(d.resumeProcesses, session.IssueIID)
		
		if err != nil {
			fmt.Printf("[%s] Resume session for issue #%d completed with error: %v\n", 
				time.Now().Format("2006-01-02 15:04:05"), session.IssueIID, err)
		} else {
			fmt.Printf("[%s] Resume session for issue #%d completed successfully\n", 
				time.Now().Format("2006-01-02 15:04:05"), session.IssueIID)
		}
	}()
	
	return nil
}

func (d *Daemon) checkForNewClaudeIssues(processedIssues map[int]bool, timestamp string) (int, error) {
	// Fetch issues with the claude label (new work)
	fmt.Printf("[%s] DEBUG: Fetching issues with label '%s' from project '%s'...\n", timestamp, d.config.Daemon.ClaudeLabel, d.selectedProject)
	issues, err := d.gitlabClient.GetProjectIssues(d.selectedProject, []string{d.config.Daemon.ClaudeLabel}, "opened")
	if err != nil {
		fmt.Printf("[%s] DEBUG: Failed to fetch claude issues: %v\n", timestamp, err)
		return 0, fmt.Errorf("failed to fetch claude issues: %v", err)
	}
	fmt.Printf("[%s] DEBUG: Successfully fetched %d issues with claude label\n", timestamp, len(issues))

	newIssues := 0
	for _, issue := range issues {
		if !processedIssues[issue.IID] {
			processedIssues[issue.IID] = true
			newIssues++

			fmt.Printf("[%s] Found new issue #%d: %s\n", timestamp, issue.IID, issue.Title)
			
			// Process issue asynchronously with automatic label updates
			if err := d.processIssueWithLabelUpdate(&issue); err != nil {
				fmt.Printf("[%s] Failed to start processing issue #%d: %v\n", timestamp, issue.IID, err)
			} else {
				fmt.Printf("[%s] Started new Claude session for issue #%d\n", timestamp, issue.IID)
			}
		}
	}

	return newIssues, nil
}

func (d *Daemon) checkForNewClaudeIssuesWithContext(ctx context.Context, processedIssues map[int]bool, timestamp string) (int, error) {
	// Check if context is already cancelled
	select {
	case <-ctx.Done():
		return 0, ctx.Err()
	default:
	}
	
	// Fetch issues with the claude label (new work) with timeout
	fmt.Printf("[%s] DEBUG: Fetching issues with label '%s' from project '%s'...\n", timestamp, d.config.Daemon.ClaudeLabel, d.selectedProject)
	
	// Create a timeout context for the API call
	apiCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	
	// Use a channel to make the API call cancellable
	type result struct {
		issues []gitlab.Issue
		err    error
	}
	
	resultCh := make(chan result, 1)
	go func() {
		issues, err := d.gitlabClient.GetProjectIssues(d.selectedProject, []string{d.config.Daemon.ClaudeLabel}, "opened")
		resultCh <- result{issues: issues, err: err}
	}()
	
	// Wait for either the result or context cancellation
	var issues []gitlab.Issue
	var err error
	select {
	case <-apiCtx.Done():
		fmt.Printf("[%s] DEBUG: API call timed out or was cancelled\n", timestamp)
		return 0, apiCtx.Err()
	case res := <-resultCh:
		issues = res.issues
		err = res.err
	}
	
	if err != nil {
		fmt.Printf("[%s] DEBUG: Failed to fetch claude issues: %v\n", timestamp, err)
		return 0, fmt.Errorf("failed to fetch claude issues: %v", err)
	}
	fmt.Printf("[%s] DEBUG: Successfully fetched %d issues with claude label\n", timestamp, len(issues))

	newIssues := 0
	for _, issue := range issues {
		// Check for cancellation between issues
		select {
		case <-ctx.Done():
			return newIssues, ctx.Err()
		default:
		}
		
		if !processedIssues[issue.IID] {
			processedIssues[issue.IID] = true
			newIssues++

			fmt.Printf("[%s] Found new issue #%d: %s\n", timestamp, issue.IID, issue.Title)
			
			// Process issue asynchronously with automatic label updates
			if err := d.processIssueWithLabelUpdate(&issue); err != nil {
				fmt.Printf("[%s] Failed to start processing issue #%d: %v\n", timestamp, issue.IID, err)
			} else {
				fmt.Printf("[%s] Started new Claude session for issue #%d\n", timestamp, issue.IID)
			}
		}
	}

	return newIssues, nil
}

func (d *Daemon) checkForReviewIssuesWithComments(timestamp string) (int, error) {
	// Fetch issues with the review label (waiting for human review)
	fmt.Printf("[%s] DEBUG: Fetching issues with label '%s' from project '%s'...\n", timestamp, d.config.Daemon.ReviewLabel, d.selectedProject)
	reviewIssues, err := d.gitlabClient.GetProjectIssues(d.selectedProject, []string{d.config.Daemon.ReviewLabel}, "opened")
	if err != nil {
		fmt.Printf("[%s] DEBUG: Failed to fetch review issues: %v\n", timestamp, err)
		return 0, fmt.Errorf("failed to fetch review issues: %v", err)
	}
	fmt.Printf("[%s] DEBUG: Successfully fetched %d issues with review label\n", timestamp, len(reviewIssues))

	resumedSessions := 0
	for _, issue := range reviewIssues {
		// Check if we have a completed session for this issue
		session, exists := d.sessionStore.GetCompletedSession(issue.IID)
		if !exists {
			// No session record, skip this issue
			continue
		}

		// Determine the cutoff time for new comments
		cutoffTime := session.CompletionTime
		if session.LastCommentTime != nil {
			cutoffTime = *session.LastCommentTime
		}

		// Check for new comments since the cutoff time
		newComments, err := d.gitlabClient.GetIssueCommentsAfter(session.ProjectPath, session.IssueIID, cutoffTime)
		if err != nil {
			fmt.Printf("[%s] Error checking comments for issue #%d: %v\n", timestamp, session.IssueIID, err)
			continue
		}

		if len(newComments) > 0 {
			fmt.Printf("[%s] Found %d new comments on issue #%d\n", timestamp, len(newComments), session.IssueIID)
			
			// Resume Claude session with new comments
			if err := d.resumeSessionWithComments(session, newComments); err != nil {
				fmt.Printf("[%s] Error resuming session for issue #%d: %v\n", timestamp, session.IssueIID, err)
				continue
			}
			
			resumedSessions++
			fmt.Printf("[%s] Resumed Claude session for issue #%d\n", timestamp, session.IssueIID)
			
			// Update last comment time to latest comment
			latestCommentTime := newComments[len(newComments)-1].CreatedAt
			if parsedTime, err := time.Parse(time.RFC3339, latestCommentTime); err == nil {
				d.sessionStore.UpdateLastCommentTime(session.IssueIID, parsedTime)
			}
		}
	}

	return resumedSessions, nil
}

func (d *Daemon) checkForReviewIssuesWithCommentsWithContext(ctx context.Context, timestamp string) (int, error) {
	// Check if context is already cancelled
	select {
	case <-ctx.Done():
		return 0, ctx.Err()
	default:
	}
	
	// Fetch issues with the review label (waiting for human review) with timeout
	fmt.Printf("[%s] DEBUG: Fetching issues with label '%s' from project '%s'...\n", timestamp, d.config.Daemon.ReviewLabel, d.selectedProject)
	
	// Create a timeout context for the API call
	apiCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	
	// Use a channel to make the API call cancellable
	type result struct {
		issues []gitlab.Issue
		err    error
	}
	
	resultCh := make(chan result, 1)
	go func() {
		reviewIssues, err := d.gitlabClient.GetProjectIssues(d.selectedProject, []string{d.config.Daemon.ReviewLabel}, "opened")
		resultCh <- result{issues: reviewIssues, err: err}
	}()
	
	// Wait for either the result or context cancellation
	var reviewIssues []gitlab.Issue
	var err error
	select {
	case <-apiCtx.Done():
		fmt.Printf("[%s] DEBUG: Review issues API call timed out or was cancelled\n", timestamp)
		return 0, apiCtx.Err()
	case res := <-resultCh:
		reviewIssues = res.issues
		err = res.err
	}
	
	if err != nil {
		fmt.Printf("[%s] DEBUG: Failed to fetch review issues: %v\n", timestamp, err)
		return 0, fmt.Errorf("failed to fetch review issues: %v", err)
	}
	fmt.Printf("[%s] DEBUG: Successfully fetched %d issues with review label\n", timestamp, len(reviewIssues))

	resumedSessions := 0
	for _, issue := range reviewIssues {
		// Check for cancellation between issues
		select {
		case <-ctx.Done():
			return resumedSessions, ctx.Err()
		default:
		}
		
		// Check if we have a completed session for this issue
		session, exists := d.sessionStore.GetCompletedSession(issue.IID)
		if !exists {
			// No session record, skip this issue
			continue
		}

		// Determine the cutoff time for new comments
		cutoffTime := session.CompletionTime
		if session.LastCommentTime != nil {
			cutoffTime = *session.LastCommentTime
		}

		// Check for new comments since the cutoff time
		newComments, err := d.gitlabClient.GetIssueCommentsAfter(session.ProjectPath, session.IssueIID, cutoffTime)
		if err != nil {
			fmt.Printf("[%s] Error checking comments for issue #%d: %v\n", timestamp, session.IssueIID, err)
			continue
		}

		if len(newComments) > 0 {
			fmt.Printf("[%s] Found %d new comments on issue #%d\n", timestamp, len(newComments), session.IssueIID)
			
			// Resume Claude session with new comments
			if err := d.resumeSessionWithComments(session, newComments); err != nil {
				fmt.Printf("[%s] Error resuming session for issue #%d: %v\n", timestamp, session.IssueIID, err)
				continue
			}
			
			resumedSessions++
			fmt.Printf("[%s] Resumed Claude session for issue #%d\n", timestamp, session.IssueIID)
			
			// Update last comment time to latest comment
			latestCommentTime := newComments[len(newComments)-1].CreatedAt
			if parsedTime, err := time.Parse(time.RFC3339, latestCommentTime); err == nil {
				d.sessionStore.UpdateLastCommentTime(session.IssueIID, parsedTime)
			}
		}
	}

	return resumedSessions, nil
}

func (d *Daemon) Run() error {
	// Step 1: Select project interactively
	fmt.Printf("=== Project Selection for Daemon Mode ===\n")
	projects, err := d.gitlabClient.GetAccessibleProjects()
	if err != nil {
		return fmt.Errorf("error fetching projects: %v", err)
	}

	selectedProject, err := d.selectProject(projects)
	if err != nil {
		return fmt.Errorf("error selecting project: %v", err)
	}

	d.selectedProject = selectedProject.PathWithNamespace
	fmt.Printf("Project selected: %s\n", d.selectedProject)

	// Step 2: Start daemon monitoring
	fmt.Printf("\n=== Starting Daemon Mode ===\n")
	if d.dryRun {
		fmt.Printf("*** DRY RUN MODE - No actual processing will occur ***\n")
	} else if d.semiDryRun {
		fmt.Printf("*** SEMI-DRY RUN MODE - Will clone repositories but not execute Claude ***\n")
	}
	fmt.Printf("Monitoring project: %s\n", d.selectedProject)
	fmt.Printf("Monitoring for issues with label: %s\n", d.config.Daemon.ClaudeLabel)
	fmt.Printf("Processing interval: %d seconds\n", d.config.Daemon.Interval)
	fmt.Printf("Press Ctrl+C to stop...\n\n")

	// Set up signal handling for graceful shutdown with context
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	
	// Cancel context when signal received
	go func() {
		<-sigCh
		fmt.Printf("\nReceived shutdown signal. Cancelling operations...\n")
		cancel()
	}()

	// Keep track of processed issues to avoid duplicates
	processedIssues := make(map[int]bool)

	ticker := time.NewTicker(time.Duration(d.config.Daemon.Interval) * time.Second)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			fmt.Printf("\nReceived shutdown signal. Stopping daemon...\n")
			
			// Gracefully stop any running processes
			runningProcesses := d.processManager.GetRunningProcesses()
			totalProcesses := len(runningProcesses) + len(d.resumeProcesses)
			
			if totalProcesses > 0 {
				fmt.Printf("Terminating %d running Claude processes...\n", totalProcesses)
				
				// Terminate regular Claude processes
				for _, process := range runningProcesses {
					if process.Cmd != nil && process.Cmd.Process != nil {
						fmt.Printf("  Terminating process for issue #%d (PID: %d)\n", process.IssueNum, process.Cmd.Process.Pid)
						process.Cmd.Process.Signal(syscall.SIGTERM)
					}
				}
				
				// Terminate resume processes
				for issueID, cmd := range d.resumeProcesses {
					if cmd != nil && cmd.Process != nil {
						fmt.Printf("  Terminating resume process for issue #%d (PID: %d)\n", issueID, cmd.Process.Pid)
						cmd.Process.Signal(syscall.SIGTERM)
					}
				}
				
				// Give processes a moment to terminate gracefully
				fmt.Printf("Waiting 3 seconds for processes to terminate...\n")
				time.Sleep(3 * time.Second)
				
				// Force kill any remaining processes
				for _, process := range runningProcesses {
					if process.Cmd != nil && process.Cmd.Process != nil {
						process.Cmd.Process.Kill()
					}
				}
				
				for _, cmd := range d.resumeProcesses {
					if cmd != nil && cmd.Process != nil {
						cmd.Process.Kill()
					}
				}
			}
			
			fmt.Printf("Daemon stopped.\n")
			return nil

		case <-ticker.C:
			// Check if context was cancelled before starting work
			select {
			case <-ctx.Done():
				fmt.Printf("\nOperation cancelled before processing\n")
				return nil
			default:
			}
			
			timestamp := time.Now().Format("2006-01-02 15:04:05")
			fmt.Printf("[%s] Checking for issues to process...\n", timestamp)

			// 1. Check for new issues with 'claude' label (spawn new sessions)
			fmt.Printf("[%s] DEBUG: Starting checkForNewClaudeIssues...\n", timestamp)
			newIssues, err := d.checkForNewClaudeIssuesWithContext(ctx, processedIssues, timestamp)
			if err != nil {
				if ctx.Err() != nil {
					fmt.Printf("[%s] Operation cancelled by user\n", timestamp)
					continue
				}
				fmt.Printf("[%s] Error checking for new claude issues: %v\n", timestamp, err)
			}
			fmt.Printf("[%s] DEBUG: Finished checkForNewClaudeIssues, found %d new issues\n", timestamp, newIssues)

			// 2. Check for issues under review with new comments (resume sessions)
			fmt.Printf("[%s] DEBUG: Starting checkForReviewIssuesWithComments...\n", timestamp)
			resumedIssues, err := d.checkForReviewIssuesWithCommentsWithContext(ctx, timestamp)
			if err != nil {
				if ctx.Err() != nil {
					fmt.Printf("[%s] Operation cancelled by user\n", timestamp)
					continue
				}
				fmt.Printf("[%s] Error checking for review issues with comments: %v\n", timestamp, err)
			}
			fmt.Printf("[%s] DEBUG: Finished checkForReviewIssuesWithComments, resumed %d sessions\n", timestamp, resumedIssues)

			// Summary
			if newIssues > 0 || resumedIssues > 0 {
				fmt.Printf("[%s] Activity: %d new sessions started, %d sessions resumed\n", timestamp, newIssues, resumedIssues)
			} else {
				fmt.Printf("[%s] No new activity found\n", timestamp)
			}
			fmt.Printf("[%s] DEBUG: Finished polling cycle, waiting for next tick...\n", timestamp)
		}
	}
}

func (d *Daemon) GetProcessStatus() {
	fmt.Printf("=== Process Status ===\n")
	
	running := d.processManager.GetRunningProcesses()
	completed := d.processManager.GetProcessesByStatus("completed")
	failed := d.processManager.GetProcessesByStatus("failed")
	
	fmt.Printf("Running processes: %d\n", len(running))
	for _, process := range running {
		fmt.Printf("  - Issue #%d (ID: %s) - Running for %v\n", 
			process.IssueNum, process.ID, time.Since(process.StartTime))
	}
	
	fmt.Printf("Completed processes: %d\n", len(completed))
	for _, process := range completed {
		fmt.Printf("  - Issue #%d (ID: %s) - Completed in %v\n", 
			process.IssueNum, process.ID, time.Since(process.StartTime))
	}
	
	fmt.Printf("Failed processes: %d\n", len(failed))
	for _, process := range failed {
		fmt.Printf("  - Issue #%d (ID: %s) - Failed after %v\n", 
			process.IssueNum, process.ID, time.Since(process.StartTime))
	}
}